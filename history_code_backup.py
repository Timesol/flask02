JOURNAL_FOLDER='/home/ahoehne/flask01/app/templates/journals/'
TEMPLATE_FOLDER='/home/ahoehne/flask01/app/templates/router_configs/'
BO_CONFIG_LINK='https://intern.inode.at/backoffice/contract/contract_config_edit.php4?Contract_ID='






Basisvar-router_mpls-dns_server1-1 : 192.168.10.8
Basisvar-net_mpls-network-1-net_ip_to-1 : 192.168.167.255
Basisvar-mpls-mpls_pe-1 : at-grz-lazg-pe02
Basisvar-router_mpls-router_sn-1 : 
Basisvar-xdsl-prev_phone_areacode-1 : 
Basisvar-router_mpls-snmp_access-1 : false
Basisvar-xdsl-koloCampaign-1 : false
Basisvar-vull-vull_dslam-1 : 
Basisvar-line_mpls-line_floor-1 : 
Basisvar-qos-advanced_service_percent-1 : 0
Basisvar-vdsl-vdsl_dhcp_ip_cnr-1 : 
Basisvar-net_mpls-network-1-net_submask-1 : 255.255.255.0
Basisvar-mpls-topology-1 : hub
Basisvar-line_mpls-line_housenr-1 : 25
Basisvar-vull-vull_dslam_loc_id-1 : 
Basisvar-router_mpls-dns_server2-1 : 192.168.10.4
Basisvar-router_mpls-physical_ip-1 : 
Basisvar-mpls_inside_net-static_ip-1 : 
Basisvar-product_bandwidth-product_bandwidth_down-1 : 12320
Basisvar-mpls-headquarters-1 : false
Basisvar-router_mpls-read_only_community-1 : caritas_mpls
Basisvar-qos-premium_service_percent-1 : 0
Basisvar-router_mpls-hsrp-1 : false
Basisvar-router_mpls-domain_name-1 : 
Basisvar-net_mpls-network-1-net_name-1 : Kundennetz 1
Basisvar-router_mpls-hsrp_gateway-1 : 
Basisvar-xdsl-traffic_limit-1 : 
Basisvar-xdsl-check-1 : Array
Basisvar-net_mpls-network-1-net_nexthop-1 : 
Basisvar-mpls-line_backup-1 : false
Basisvar-router_mpls-trusted_host_ip-1 : 192.168.10.0
Basisvar-router_mpls-dhcp_start_ip-1 : 192.168.167.150
Basisvar-xdsl-installservice-1 : false
Basisvar-xdsl-xdsl_wan_ip-1 : 
Basisvar-net_mpls-net_common_name-1 : MPLS-Kundennetz
Basisvar-hardware-username-1 : 
Basisvar-xdsl-prev_phone_number-1 : 
Basisvar-hardware-enable_password-1 : emuevuln
Basisvar-vdsl-nima_hostname-1 : 
Basisvar-qos-standard_service_percent-1 : 100
Basisvar-vull-vull_phone-1 : 
Basisvar-line_mpls-line_city-1 : Gleisdorf
Basisvar-vdsl-hsi_line_backup-1 : false
Basisvar-line_mpls-line_install_date_ta-1 : 
Basisvar-vdsl-vdsl_guid-1 : 
unlock : true
Basisvar-router_mpls-dhcp_pool_size-1 : 103
Basisvar-line_mpls-line_door-1 : 1
Basisvar-net_mpls-network-1-net_ip_from-1 : 192.168.167.0
Basisvar-mpls_inside_net-gateway_virtual_ip-1 : 172.17.98.1
Basisvar-xdsl-xdsl_concentrator_gateway-1 : 
Basisvar-line_mpls-contact_phone-1 : 03168015240
Basisvar-mpls_inside_net-subnetmask-1 : 255.255.255.252
Basisvar-xdsl-suppress_uzf_mail-1 : false
Basisvar-xdsl-ta_clientnr-1 : 
Basisvar-mpls-vrf_id-1 : 25131
Basisvar-line_mpls-line_street-1 : BÃ¼rgergasse
Basisvar-xdsl-radius_max_logins-1 : 
Basisvar-mpls-mpls_interface-1 : Gi203/0/0/36.1301
Basisvar-xdsl-username-1 : 
service_class_premium[] : video
Basisvar-net_mpls-network-1-net_ip-1 : 256
Action : Config.Save
Basisvar-router_mpls-router_sn_master-1 : 
Basisvar-hardware-password-1 : 0zilrmna
Basisvar-line_mpls-line_zipcode-1 : 8200
Submit : NA
Basisvar-mpls-automatic_completion-1 : false
Basisvar-net_mpls-network-1-net_config_public-1 : false
Basisvar-mpls-mpls_vlan-1 : 1301
Basisvar-vull-vull_line_type-1 : 
Basisvar-net_mpls-network-1-net_vip-1 : 
Basisvar-router_mpls-dhcp_relay_server-1 : 
Basisvar-xdsl-xdsl_concentrator_submask-1 : 
Basisvar-router_mpls-dhcp_active-1 : relay
Basisvar-mpls_inside_net-wan_router_ip-1 : 172.17.98.2
searchStr : 
Basisvar-line_mpls-line_stairway-1 : 
Basisvar-mpls-vrf_name_spoke-1 : 
Basisvar-router_mpls-router_management_ip-1 : 172.23.5.4
Basisvar-product_bandwidth-product_bandwidth_up-1 : 1024
Basisvar-net_mpls-network-1-net_gateway-1 : 192.168.167.1
PaymentSave : alle Konfigurationen speichern
Basisvar-router_mpls-trusted_host_subnet-1 : 255.255.255.0
Basisvar-mpls-mpls_vlan_name-1 : CARITAS-1463695
Basisvar-xdsl-xdsl_kuda-1 : 
Basisvar-router_mpls-bgp_neighbor-1 : 172.17.98.1
Basisvar-xdsl-password-1 : 
Basisvar-mpls-vrf_id_spoke-1 : 
Basisvar-xdsl-xdsl_speed-1 : 12320/1024
Basisvar-mpls-vrf_name-1 : 04325131:B2B_CARITAS
Basisvar-line_mpls-contact_person-1 : Sylvia Paltauf
Basisvar-mpls-mpls_gateway-1 : 
Basisvar-xdsl-install_termin-1 : 28.12.2018 15:00 - 28.12.2018 17:00
Basisvar-vull-vull_vlan-1 : 





























'''
Test paramiko, pxssh etc.




try:
    s = pxssh.pxssh()
    hostname = input('hostname: ')
    username = input('username: ')
    password = getpass.getpass('password: ')
    s.login(hostname, username, password)
    s.sendline('eval "{ sleep 1; echo username; sleep 1; echo password; sleep 1; echo df; sleep 5; }" | telnet 192.168.0.136') 
    s.prompt()             
    print(s.before)        
   
    
except pxssh.ExceptionPxssh as e:
    print("pxssh failed on login.")
    print(e)

'''



'''





import threading, paramiko
import paramiko as ssh
 

class ssh:
    shell = None
    client = None
    transport = None
 
    def __init__(self, address, username, password):
        print("Connecting to server on ip", str(address) + ".")
        self.client = paramiko.client.SSHClient()
        self.client.set_missing_host_key_policy(paramiko.client.AutoAddPolicy())
        self.client.connect(address, username=username, password=password, look_for_keys=False)
        self.transport = paramiko.Transport((address, 22))
        self.transport.connect(username=username, password=password)
 
        thread = threading.Thread(target=self.process)
        thread.daemon = True
        thread.start()
 
    def closeConnection(self):
        if(self.client != None):
            self.client.close()
            self.transport.close()
 
    def openShell(self):
        self.shell = self.client.invoke_shell()
 
    def sendShell(self, command):
        if(self.shell):
            self.shell.send(command + "\n")
        else:
            print("Shell not opened.")
 
    def process(self):
        global connection
        while True:
            # Print data when available
            if self.shell != None and self.shell.recv_ready():
                alldata = self.shell.recv(1024)
                while self.shell.recv_ready():
                    alldata += self.shell.recv(1024)
                strdata = str(alldata, "utf8")
                strdata.replace('\r', '')
                print(strdata, end = "")
                if(strdata.endswith("$ ")):
                    print("\n$ ", end = "")


    def sendCommand(self, command):
        if(self.client):
            stdin, stdout, stderr = self.client.exec_command(command)
            while not stdout.channel.exit_status_ready():
                # Print data when available
                if stdout.channel.recv_ready():
                    alldata = stdout.channel.recv(1024)
                    prevdata = b"1"
                    while prevdata:
                        prevdata = stdout.channel.recv(1024)
                        alldata += prevdata
 
                    print(str(alldata, "utf8"))
        else:
            print("Connection not opened.")



 
 
sshUsername = "ahoehne"
sshPassword = "net7toor"
sshServer = "192.168.0.192"
 
 
connection = ssh(sshServer, sshUsername, sshPassword)
connection.openShell()
while True:
    command = input('$ ')
    if command.startswith(" "):
        command = command[1:]
    connection.sendShell(command)





    





'''





''' @bp.route('/query',methods=['GET', 'POST'])
@login_required

def query():
    no=request.args.get('no')

    location=Location.query.get(no)
    d={}
    for i in location.networks:
        netid='network'+ str(i.id)
        netid=str(netid)
        id= 'id'+ str(i.id)
        print(netid)
        a={
        id : i.name,
        netid : i.network}
        d.update(a)

    
    print (d)

    locr=location.residence
    locp=location.project
    locpm=location.projectmanager  
    loch=location.hardware
    loct=location.technology
    locc=location.contract
    d1={'locr':locr,'locp':locp,'locpm':locpm,'loch':loch,'loct':loct,'locc':locc, }
    d2=d
    d1.update(d2)
    
    return json.dumps(d1); '''



'''

@bp.route('/insert')
def insert():
    return render_template('insert.html')



'''



s=requests.Session()
username='ahoehne'
password='Katze7436!'
s.auth=(username,password)
c=s.get('https://intern.inode.at/backoffice/contract/contract_config_edit.php4?Contract_ID=1463383')
s.cookies=c.cookies
print(c.status_code)
print('global session cookie')
print(c.cookies)
method_requests_mapping = {
    'GET': s.get,
    'HEAD': s.head,
    'POST': s.post,
    'PUT': s.put,
    'DELETE': s.delete,
    'PATCH': s.patch,
    'OPTIONS': s.options,
}

@bp.route('/<path:url>', methods=['GET', 'POST'])
def root(url):
    #LOG.info("Root route, path: %s", url)
    # If referred from a proxy request, then redirect to a URL with the proxy prefix.
    # This allows server-relative and protocol-relative URLs to work.
    proxy_ref = proxy_ref_info(request)
    if proxy_ref:
        redirect_url = "/p/%s/%s%s" % (proxy_ref[0], url, ("?" + str(request.query_string) if request.query_string else ""))
        #LOG.info("Redirecting referred URL to: %s", redirect_url)

        return redirect(redirect_url)
    # Otherwise, default behavior
    return render_template('index.html', name=url,request=request)



@bp.route('/<path:url>', methods=method_requests_mapping.keys())
def proxy(url):
    print('function session cookie')
    print(c.cookies)
    

    url='https://intern.inode.at/'+url
   # requests.utils.add_dict_to_cookiejar(s.cookies,c.cookies)
    cookies=dict(test='Feuer')
    requests_function = method_requests_mapping[flask.request.method]
    request = requests_function(url, stream=True, params=flask.request.args,allow_redirects=False, cookies=cookies)
    
    response = flask.Response(flask.stream_with_context(request.iter_content()),
                              content_type=request.headers['content-type'],
                              
                              status=request.status_code, )
    print('request session cookie')
    print(request.cookies)
    
    
    
    return response





    


   

proxy.counter= 0
    



s=requests.Session()
username='ahoehne'
password='Katze7436!'
s.auth=(username,password)
c=s.get('https://intern.inode.at/backoffice/contract/contract_config_edit.php4?Contract_ID=1463383')
s.cookies=c.cookies
print(c.status_code)
print('global session cookie')
print(c.cookies)
method_requests_mapping = {
    'GET': s.get,
    'HEAD': s.head,
    'POST': s.post,
    'PUT': s.put,
    'DELETE': s.delete,
    'PATCH': s.patch,
    'OPTIONS': s.options,
}



@bp.route('/<path:url>', methods=method_requests_mapping.keys())
def proxy(url):
    print('function session cookie')
    print(c.cookies)
    

    url='https://intern.inode.at/'+url
   # requests.utils.add_dict_to_cookiejar(s.cookies,c.cookies)
    cookies=dict(test='Feuer')
    requests_function = method_requests_mapping[flask.request.method]
    request = requests_function(url, stream=True, params=flask.request.args,allow_redirects=True, cookies=cookies)
    
    response = flask.Response(flask.stream_with_context(request.iter_content()),
                              content_type=request.headers['content-type'],
                              
                              status=request.status_code, )
    print('request session cookie')
    print(request.cookies)
    
    
    
    return response





    


   

proxy.counter= 0
   


